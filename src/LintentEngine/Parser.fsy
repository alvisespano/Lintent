%{
open FSharpCommon.Prelude
open LintentEngine.Absyn
open LintentEngine.Absyn.Dlm
open LintentEngine.Absyn.ParseAux

module J = LintentEngine.Absyn.Java

exception ParseErrorContext of obj

let parse_error_rich = Some (fun ctx -> raise (ParseErrorContext ctx))

let mutable current_filename = "<no-filename>"

%}
 
%token <System.String> ID
%token EOF

%token <LintentEngine.Absyn.qid> QID
%token <string> FILENAME
%token <int> INT_LIT
%token <int64> LONG_LIT
%token <float> DOUBLE_LIT
%token <float32> FLOAT_LIT
%token <char> CHAR_LIT
%token <string> STRING_LIT
%token READ WRITE COMMA MEET JOIN BRA KET SEMICOLON TOP BOTTOM COLON SQBRA NONE EOL CUR LY
%token TRUE FALSE ASSIGN RETURN THROW IF WHILE DO_WHILE FOR FOR_EACH TRY SWITCH BREAK CONTINUE THIS_CONS SUPER_CONS ASSERT PREDEC 
%token LABELLED_STATEMENT THIS NULL CAST CALL SELECT SUBSCRIPT CONS INL_IF UNARY_EXPR CLASS_OP ARRAY_INIT NEG NOT PREINC POSTINC ASHR
%token INT BOOLEAN LONG FLOAT DOUBLE SHORT BYTE PLUS MINUS MULT DIV MOD LSH RSH AND OR XOR EQ NEQ LT GT LEQ GEQ LAND LOR BNOT CHAR POSTDEC
%token UPLUS ARSH PUBLIC PRIVATE PACKAGE PROTECTED WILDCARD_EXT WILDCARD_SUP WILDCARD SUPER DOT ARRAY_LIT USES_PERMISSIONS
%token CALLING_PERMISSIONS DEFINES_PERMISSIONS IMPLICIT_IMPORTS 

%left JOIN
%left MEET
%left WMEET
%left WJOIN
%right SEMICOLON
%nonassoc READ WRITE
%left COMMA

%type < label > label
%type < J.program > lombok_java_program
%type < (J.id * J.ty) list > intent_annotations
%type < qid * J.method_signature > x_api_call_line__method_signature
%type < X.perm_expr > x_api_call_line__perm_expr
%type < X.implicit_call > x_implicit_call_line

%start label
%start lombok_java_program
%start intent_annotations
%start x_api_call_line__perm_expr
%start x_api_call_line__method_signature
%start x_implicit_call_line

%%

/* x action strings */

x_implicit_call_line:
    x_action_string COMMA x_perm					{ { X.implicit_call.action_string = $1;
                                                        X.implicit_call.call_perms = [$3] } }

x_action_string:
    x_any_id									{ $1 }

x_perm:
    x_any_id									{ $1 }

x_any_id:
/*  ID											{ $1 }*/
  | QID											{ $1.pretty }


/* x api call */

x_api_call_line__perm_expr:
    x_any_id													{ X.P_Id $1 }
  | x_api_call_line__perm_expr OR x_api_call_line__perm_expr	{ X.P_Or ($1, $3) }
  | x_api_call_line__perm_expr AND x_api_call_line__perm_expr	{ X.P_And ($1, $3) }
  | BRA x_api_call_line__perm_expr KET							{ $2 }

x_api_call_line__method_signature:
    QID BRA KET									{ build_x_method_signature $1 [] None parseState }
  | QID BRA x_types KET							{ build_x_method_signature $1 $3 None parseState }


/* NOTE: return types are not specified because they're not needed for api call detection
  | QID BRA KET	x_type							{ build_x_method_signature $1 [] (Some $4) parseState }
  |	QID BRA x_types KET x_type					{ build_x_method_signature $1 $3 (Some $5) parseState }*/

x_type:
    QID											{ J.Ty_QId $1 }
  | ID											{ J.Ty_QId (qid.of_string $1) }
  | builtin_ty									{ J.Ty_Builtin $1 }
  | SQBRA x_type								{ J.Ty_Array $2 }

x_types:
    x_type										{ [$1] }
  | x_type COMMA x_types						{ $1 :: $3 }
           

/* intent annotation */

intent_annotation:
    intent_annotation_ EOF								{ $1 }

intent_annotation_:
    ID COLON intent_annotation_type						{ $1, $3 }
  | intent_annotation_type ID							{ $2, $1 }

intent_annotations:
    intent_annotation									{ [$1] }
  | intent_annotation SEMICOLON intent_annotations		{ $1 :: $3 }
  | intent_annotation COMMA intent_annotations			{ $1 :: $3 }

intent_annotation_type:
    builtin_ty											{ J.Ty_Builtin $1 }
  | ID													{ J.Ty_QId (qid.of_string $1) }
  | QID													{ J.Ty_QId $1 }
  | intent_annotation_type LT intent_annotation_types GT { J.Ty_App ($1, List.map J.TyArg_Ty $3) }

intent_annotation_types:
    intent_annotation_type									{ [$1] }
  | intent_annotation_type COMMA intent_annotation_types	{ $1 :: $3 }


/* Lombok-Java grammar */

lombok_java_program:
    uses_perms defines_perms calling_perms
        implicit_imports compilation_units EOF			{ let m = new J.manifest (uses_permissions = $1, defines_permissions = $2, 
                                                                                  calling_permissions = $3) in
                                                          J.program (compilation_units = $5, manifest = m, implicit_imports = $4) }

calling_perms:
    CALLING_PERMISSIONS BRA KET							{ [] }
  | CALLING_PERMISSIONS BRA calling_perms_list KET		{ $3 }

calling_perms_list:
    BRA QID STRING_LIT KET								{ [(FQId $2, $3)] }
  | BRA QID STRING_LIT KET calling_perms_list			{ (FQId $2, $3) :: $5 }

uses_perms:
    USES_PERMISSIONS BRA KET							{ [] }
  | USES_PERMISSIONS BRA uses_list KET					{ $3 }

uses_list:
    STRING_LIT											{ [$1] }
  | STRING_LIT COMMA uses_list							{ $1 :: $3 }

defines_perms:
    DEFINES_PERMISSIONS BRA KET							{ [] }
  | DEFINES_PERMISSIONS BRA perms_list KET				{ $3 }
  
perms_list:
    permission											{ [$1] }
  | permission perms_list								{ $1 :: $2 }

permission:
    BRA STRING_LIT STRING_LIT STRING_LIT STRING_LIT
        STRING_LIT STRING_LIT KET						{ J.permission (description = $2, icon = $3, label = $4,
                                                                name = $5, group = $6, level = $7) }

implicit_imports:
    IMPLICIT_IMPORTS BRA import_decl_list KET			{ $3 }


compilation_units:
    compilation_unit									{ [$1] }
  | compilation_unit compilation_units					{ $1 :: $2 }

compilation_unit:
    FILENAME								
    ID BRA QID KET import_decls class_decls 
        interface_decls									{ new J.compilation_unit (filename = $1, package = FQId $4,
                                                               imports = $6,
                                                               public_class_name = $2, classes = $7, interfaces = $8) }

import_decls:
    BRA KET												{ [] }
  | BRA import_decl_list KET							{ $2 }

import_decl_list:
    import_decl											{ [$1] }
  | import_decl import_decl_list						{ $1 :: $2 }

import_decl:
    QID bool_lit 										{ FQId $1 }

class_decls:
    BRA KET												{ [] }
  | BRA class_decl_list	KET								{ $2 }

class_decl_list:
    class_decl											{ [$1] }
  | class_decl class_decl_list							{ $1 :: $2 }

class_decl:
    ID modifiers ty_params class_extends 
      implements class_body								{   let (visib, mods, anns) = $2 in                                                            
                                                            new J.classs (name = $1, modif = build_class_modifs visib mods, 
                                                                annots = anns, ty_params = $3, extends = $4, implements = $5,
                                                                body = $6) 
                                                        }
     
class_body: 
     attribute_decls constructor_decls 
      method_decls class_inits static_inits 
      inner_classes inner_interfaces loc				{ new J.class_body (attributes = $1, methods =$3, constructors = $2,
                                                            inner_classes =$6, inner_interfaces = $7, initializer = $4,
                                                            static_initializer = $5, loc = $8) }			

class_inits:
    BRA KET												{ [] }
  | BRA body KET										{ $2 }

static_inits:
    BRA KET												{ [] }
  | BRA body KET										{ $2 }

interface_decls:
    BRA KET												{ [] }
  | BRA interface_decl_list KET							{ $2 }

interface_decl_list:
    interface_decl										{ [$1] }
  |	interface_decl interface_decl_list					{ $1 :: $2 }

interface_decl:
    ID modifiers ty_params implements attribute_decls 
      method_decls inner_classes inner_interfaces loc	{ let meth_sigs = List.map (fun m -> m :> J.method_signature) $6 in
                                                          let (visib, mods, anns) = $2 in
                                                          J.interfacee (name = $1, ty_params = $3, annots = anns,
                                                              attributes = $5, method_signatures = meth_sigs, 
                                                              inner_classes = $7, inner_interfaces = $8, extends = $4,
                                                              modif = build_class_modifs visib mods, loc = $9)
                                                        }

modifiers:
    BRA KET												{ (J.Package, Array.create 6 false, []) }
  |	BRA modifiers_flags annots KET						{ let (v, ms) = $2 in (v, ms, $3) }

modifiers_flags:
    visibility bool_lit bool_lit bool_lit 
      bool_lit bool_lit bool_lit						{ ( $1, [| $2;$3;$4;$5;$6;$7 |] ) }

visibility:
    PUBLIC												{ J.Public }	
  | PRIVATE												{ J.Private }
  | PROTECTED											{ J.Protected }
  | PACKAGE												{ J.Package }

annots:
    BRA KET												{ [] }
  | BRA annot_list KET									{ $2 }

annot_list:
    annot												{ [$1] }
  | annot annot_list									{ $1 :: $2 }

annot:
    ty annot_elements loc								{ new J.annotation (name = ($1: J.ty).reifiable.pretty, bindings = $2, loc = $3) }

annot_elements:
    BRA	KET												{ [] }
  | BRA annot_element_list KET							{ $2 }

annot_element_list:
    annot_element										{ [$1] }
  | annot_element annot_element_list					{ $1 :: $2 }

annot_element:
    ID lit												{ ($1, $2) }
  | ID BRA expr_list KET								{ ($1, J.Array (J.Ty_String, $3)) }

ty_params:
    BRA KET												{ [] }
  | BRA ty_param_list KET								{ $2 }

ty_param_list:
    ty_param											{ [$1] }
  | ty_param ty_param_list								{ $1 :: $2 }

ty_param:
    ID BRA KET											{ { name = $1; parent = J.Ty_Object; interfaces = [] } }
  | ID BRA ty_list KET								    { { name = $1; parent = List.head $3; interfaces = List.tail $3 } }
    
throws:
    BRA KET												{ [] }
  | BRA ty_list KET										{ $2 }

ty_list:
    ty													{ [$1] }
  | ty ty_list											{ $1 :: $2 }

ty:
/* TODO: Sistemare quando cambieremo AST */
  | ty_parts INT_LIT									{ rebuild_type_from_parts $2 $1 }
  | builtin_ty ty_args INT_LIT							{ build_tyarray_from_dims (J.Ty_Builtin $1) $3 }  

ty_parts:
    ID ty_args											{ [($1,$2)] }
  | ID ty_args DOT ty_parts								{ ($1,$2) :: $4 }

wildcard_kind:
    WILDCARD_EXT										{ J.Extends }
  | WILDCARD_SUP										{ J.Super }

ty_args:
    BRA KET												{ [] }
  | BRA ty_arg_list KET									{ $2 }

ty_arg:
    ty													{ J.TyArg_Ty $1 }
  | wildcard_kind ty									{ J.TyArg_Wildcard ($1, $2) }
  | WILDCARD											{ J.TyArg_Wildcard (J.Extends, J.Ty_Object) }

ty_arg_list:
  | ty_arg												{ [$1] }	
  | ty_arg ty_arg_list									{ $1 :: $2 }	

class_extends:
    BRA KET 											{ None }
  | BRA ty KET											{ Some $2 }

implements:
    BRA KET												{ [] }
  | BRA ty_list KET										{ $2 }

attribute_decls:
    BRA KET												{ [] }
  | BRA var_decl_list KET								{ $2 }

var_decl_list:
    var_decl											{ [build_attr $1] }
  | var_decl var_decl_list								{ (build_attr $1) :: $2 }

var_decl:
    var ty modifiers loc								{ let (id, eo) = $1 in let (v, ms, anns) = $3 in 
                                                          (v, ms, id, $2, eo, anns, $4) }
    /* TODO: Supportare varargs */

var:
    ID BRA KET	  										{ ($1, None) }
  | ID BRA expr KET										{ ($1, Some $3) }

constructor_decls:
    BRA KET												{ [] }
  | BRA constructor_decl_list KET						{ $2 }

constructor_decl_list:
    constructor_decl									{ [$1] }
  |	constructor_decl constructor_decl_list				{ $1 :: $2 }

constructor_decl:
    QID modifiers ty_params paramss throws body loc		{ let (v, ms, anns) = $2 in 
                                                          J.constructorr (modif = build_constr_modifs v ms, name = $1.id, 
                                                              body = $6, paramss = $4, annots = anns, ty_params = $3,
                                                              throws = $5, loc = $7) }
/* TODO: Aggiungere ty_params a constructorr */

method_decls:
    BRA KET												{ [] }
  | BRA method_decl_list KET							{ $2 }

method_decl_list:
    method_decl											{ [$1] }
  |	method_decl method_decl_list						{ $1 :: $2 }

method_decl:
    ID ret_type modifiers ty_params paramss 
        throws body loc									{ let (v, ms, anns) = $3 in 
                                                          J.methodd (modif = build_method_modifs v ms, name = $1, rty = $2,
                                                              ty_params = $4, paramss = $5, throws = $6, body = $7, loc = $8,
                                                              annots = anns)
                                                        }

ret_type:
    BRA KET												{ None }
  |	BRA ty KET											{ Some $2 }

paramss:
    BRA KET												{ [] }
  | BRA params_list KET									{ $2 }

params_list:
    var_decl											{ [build_param $1] }
  | var_decl params_list								{ (build_param $1) :: $2 }

args:
    BRA KET												{ [] }
  | BRA expr_list KET									{ $2 }

/*args_list:
    expr												{ [$1] }
  | expr COMMA args_list								{ $1 :: $2 }*/

body:
    BRA KET												{ [] }
  | BRA statement_list KET								{ $2 }

statement_list:
    statement											{ [$1] }
  | statement statement_list							{ $1 :: $2 }

statement:
    expr												{ J.Locatable (J.StatementExpr $1, $1.location) }
  | var_decl											{ let (_, ms, id, ty, eo, anns, loc) = $1 in 
                                                          J.Locatable (J.Decl (build_decl_modifiers ms, (ty, id, anns), eo), loc) }
  | BRA expr ASSIGN expr loc KET    					{ J.Locatable (J.Assign ($2, $4), $5) }
  | RETURN BRA expr loc KET  							{ J.Locatable (J.Return (Some $3), $4) }
  | RETURN BRA loc KET 									{ J.Locatable (J.Return None, $3) }
  | THROW BRA expr loc KET 								{ J.Locatable (J.Throw $3, $4) }
  | IF BRA expr body body loc KET 	    				{ J.Locatable (J.If ($3, $4, match $5 with | [] -> None | l -> Some l), $6) }
  | WHILE BRA expr body loc KET							{ J.Locatable (J.While ($3, $4), $5) }
  | DO_WHILE BRA expr body loc KET 						{ J.Locatable (J.DoWhile ($4, $3), $5) }
  | FOR BRA for_init condition update body loc KET  	{ J.Locatable (J.For ($3, $4, $5, $6), $7) }
  | FOR_EACH BRA var_decl expr body loc KET 			{ let (_, _, id, ty, _, anns, _) = $3 in 
                                                          J.Locatable (J.ForEach ((ty, id, anns), $4, $5), $6) }
  | TRY BRA body catches finallyy loc KET				{ J.Locatable (J.Try ($3, $4, $5), $6) }
  | SWITCH BRA expr cases defaultt loc KET  			{ J.Locatable (J.Switch ($3, $4, $5), $6) }
  | BREAK lb loc										{ J.Locatable (J.Break $2, $3) }
  | CONTINUE lb	loc										{ J.Locatable (J.Continue $2, $3) }
  | THIS_CONS BRA ty_args args loc KET  				{ J.Locatable (J.ThisCons ($3, $4), $5) }
  | SUPER_CONS BRA ty_args args loc KET  				{ J.Locatable (J.SuperCons ($3, $4), $5) }
  | ASSERT BRA expr assert_msg loc KET  				{ J.Locatable (J.Assert ($3, $4), $5) }
  | LABELLED_STATEMENT BRA ID statement loc KET 		{ J.Locatable (J.Labeled ($3, $4), $5) }

lb:
    BRA KET												{ None }
  | BRA ID KET											{ Some $2 }

for_init:
    BRA KET												{ None }
  | BRA statement KET									{ Some $2 }
    
condition:
    BRA KET												{ None }									
  | BRA expr KET										{ Some $2 } 

update:
    BRA KET												{ None }									
  | BRA statement KET									{ Some $2 } 

catches:
    BRA KET												{ [] }
  | BRA catch_list KET									{ $2 }

catch_list:
    var_decl body										{ [(build_param $1, $2)] }
  | var_decl body catch_list							{ (build_param $1, $2) :: $3 }

finallyy:
    BRA KET												{ None }
  | BRA statement_list KET								{ Some $2 }

cases:
    BRA KET												{ [] }
  | BRA case_list KET									{ $2 }

case_list:
    expr body 											{ [($1, $2)]  }
  | expr body case_list									{ ($1, $2) :: $3 }

defaultt:
    BRA KET												{ None }
  | BRA statement_list KET								{ Some $2 }

assert_msg:
    BRA KET												{ None }
  | BRA expr KET										{ Some $2 }


/* Espressioni non possono essere suddivise in expr+loc per via del fatto che alcune hanno necessità di KET.
 * Se si porta fuori anche la KET la grammatica diventa ambigua. */
expr:
    THIS loc											{ J.Locatable (J.This, $2) }
  | NULL loc											{ J.Locatable (J.Lit J.Null, $2) }
  | lit													{ J.UL (J.Lit $1) }
  | member_sel loc KET									{ J.Locatable (J.MemberSel $1, $2) }											
  | ID loc												{ J.Locatable (J.Var $1, $2) }
  | CAST BRA ty expr loc KET							{ J.Locatable (J.Cast ($3, $4), $5) }
  | SUBSCRIPT BRA expr expr loc KET						{ J.Locatable (J.Subscript ($3, $4), $5) }
  | CONS BRA ty ty_args args anon_class loc KET   		{ J.Locatable (J.Cons ($3, ($4, $5), $6), $7) }
/* TODO: Gestire bene gli anon_body */
  | INL_IF BRA expr	expr expr loc KET   				{ J.Locatable (J.Cond ($3, $4, $5), $6) }
  | BRA expr bin_op expr loc KET    					{ J.Locatable (J.BinOp ($2, $3, $4), $5) }
  | BRA expr un_op loc KET  							{ J.Locatable (J.UnOp ($3, $2), $4) }
  | CLASS_OP BRA ID loc KET								{ J.Locatable (J.Lit (J.ClassOp (qid.of_string $3)), $4) }
  | CLASS_OP BRA QID loc KET    						{ J.Locatable (J.Lit (J.ClassOp $3), $4) }

anon_class:
    BRA KET												{ None }
  | BRA class_body KET									{ Some $2 }

array_sizes:
    BRA KET												{ [None] }
  | BRA expr_option_list KET							{ $2 }

expr_option_list:
    expr												{ [Some $1] }
  | COMMA												{ [None; None] }
  | expr COMMA											{ [Some $1; None] }
  | expr COMMA expr_option_list							{ Some $1 :: $3 }

member_sel:
    CALL BRA ID ty_args args  							{ J.Call (J.UL J.This, $3, $4, $5) }
  | CALL BRA expr ID ty_args args   					{ J.Call ($3, $4, $5, $6) }
  | CALL BRA SUPER ID ty_args args						{ J.SuperCall ($4, $5, $6) }
  | SELECT BRA expr ID									{ J.Sel ($3, $4) }
  | SELECT BRA SUPER ID									{ J.SuperSel $4 }
  
  /* quest'ultimo caso non dovrebbe mai accadere perché purtroppo lombok scompone sempre in Select tutti i dot 
  | CALL BRA QID ID ty_args args     					{ J.StaticCall ($3, $4, $5, $6) }*/

bin_op:
    PLUS												{ J.Plus }
  | MINUS												{ J.Minus }
  | MULT												{ J.Mult }
  | DIV													{ J.Div }
  | MOD													{ J.Mod }
  | LSH													{ J.ShL }
  | RSH													{ J.ShR }
  | AND													{ J.And }
  | OR													{ J.Or }
  | XOR													{ J.Xor }         
  | EQ													{ J.Eq }
  | NEQ													{ J.Neq }
  | LT													{ J.Lt }
  | GT													{ J.Gt }
  | LEQ													{ J.Leq }
  | GEQ													{ J.Geq }    
  | LAND												{ J.LAnd } 
  | LOR													{ J.LOr } 
  | ASHR												{ J.AShR }                    
   
un_op:
    NEG													{ J.Neg }
  | NOT													{ J.Not }
  | PREINC												{ J.PreInc }
  | POSTINC												{ J.PostInc }
  | PREDEC												{ J.PreDec } 
  | POSTDEC												{ J.PostDec }

inner_classes:
    BRA KET												{ [] }
  |	BRA class_decl_list KET								{ $2 }

inner_interfaces: 
    BRA KET												{ [] }
  | BRA interface_decl_list KET							{ $2 }

expr_list:
    expr												{ [$1] }
  | expr COMMA expr_list								{ $1 :: $3 }

lit:
    ARRAY_LIT BRA ty
    ARRAY_INIT BRA BRA array_inits KET loc KET KET		{ J.Array ($3, List.map (fun f -> f $3) $7) }
  | STRING_LIT											{ J.String $1 }
  | bool_lit 											{ J.Bool $1 }
  | CHAR_LIT											{ J.Char $1 }
  | INT_LIT 											{ J.Int $1 }
  | LONG_LIT 											{ J.Long $1 }
  | FLOAT_LIT											{ J.Float $1 }
  | DOUBLE_LIT											{ J.Double $1 }

array_inits:
    array_init											{ [$1] }
  | array_init COMMA array_inits						{ $1 :: $3 }

array_init:
    ARRAY_INIT BRA BRA array_inits KET loc KET   		{ fun (ty : J.ty) -> J.Locatable (J.Lit (J.Array (ty, List.map (fun f -> f ty) $4)), $6) }
  | expr												{ fun _ -> $1 }

builtin_ty:
    INT													{ J.Ty_Int }
  | BOOLEAN												{ J.Ty_Bool }
  | LONG												{ J.Ty_Long }
  | FLOAT												{ J.Ty_Float }
  | DOUBLE												{ J.Ty_Double }
  | SHORT												{ J.Ty_Short }
  | BYTE												{ J.Ty_Byte }
  | CHAR												{ J.Ty_Char }

bool_lit:
    TRUE												{ true }
  | FALSE												{ false }

loc:
    BRA INT_LIT INT_LIT INT_LIT KET						{ new location (filename = current_filename, line = $2, col = $3, end_col = $4) }



/* DLM grammar */


label:
    label_ EOF										{ $1 }
  | array_label										{ $1 :> label }

array_label:
  | CUR label_ LY EOF								{ (new array_label (variable_label = $2)) }
  | CUR label_ LY label								{ (new array_label (variable_label = $2, type_label = new array_label ($4))) }

label_:
    reader_policy_set SEMICOLON writer_policy_set	{ new label (secrecy = $1, integrity = $3) }
  |	reader_policy_set 								{ new label (secrecy = $1) }
  |	writer_policy_set 								{ new label (integrity = $1) }

reader_policy_set:
    reader_policy									{ new secrecy_policy_set ([$1]) }
  | reader_policy_set MEET reader_policy_set		{ $1.meet $3 }
  | reader_policy_set JOIN reader_policy_set		{ $1.join $3 }
/*| reader_policy_set SEMICOLON reader_policy_set	{ $1.join $3 }*/
  | BRA reader_policy_set KET						{ $2 }

writer_policy_set:
    writer_policy												{ new integrity_policy_set ([$1]) }
  | writer_policy_set MEET writer_policy_set %prec WMEET		{ $1.meet $3 }
  | writer_policy_set JOIN writer_policy_set %prec WJOIN		{ $1.join $3 }
/*| writer_policy_set SEMICOLON writer_policy_set %prec WMEET	{ $1.meet $3 }*/
  | BRA writer_policy_set KET									{ $2 }

reader_policy:
    principal READ principals								{ new reader_policy ($1, Set ($3)) }
  |	principal READ											{ new reader_policy ($1) }

writer_policy:
    principal WRITE principals								{ new writer_policy ($1, Set ($3)) }
  |	principal WRITE											{ new writer_policy ($1) }

principal:
  | ID												{ Principal $1 }
  | TOP												{ Top }
  | BOTTOM											{ Bottom }

principals:
    principal										{ [$1] }
  | principal COMMA principals						{ $1 :: $3 }



